[{"content":"## Bullet and Dependency Injection\n\n[Dependency injection](http:\/\/www.martinfowler.com\/articles\/injection.html) is\na powerful design convention that can help separate your app routing logic\nfrom the external services it needs (like a database connection, a user\nmanagement system, and so on). That separation means your app will stay\nlightweight and flexible, easier to modify and better able to absorb external\nchanges.\n\nBullet itself is built on [Pimple 1.x](http:\/\/pimple.sensiolabs.org\/), a simple\ndependency injection container, so injection capability is automatically\navailable in your apps.\n\n## Revisiting the Bullet Blog\n\nOur blog so far uses two external services:\n\n* `somehowGetBlogMapper()`, a function that returns a database mapper for the\n  blog content and operations\n* A `Post` object that we use to create a new blog post\n\nLet's work on that first one. `somehowGetBlogMapper()` currently takes no\narguments, which means it must be figuring out the database connection\ninternally. That's not very flexible--if we wanted to change the connection\nsettings, we'd have to go fiddle around in the middle of the function. If there\nare more functions that need a database connection, we'd have to go fiddle with\nall of them!\n\nLet's change our blog mapper by adding the database connection as a parameter\n(a.k.a. injecting a dependency):\n\n{% geshi 'php' %}function somehowGetBlogMapper($database_connection) {\n    \/\/ use $database_connection to get the blog mapper\n}{% endgeshi %}\n\nGreat, much more flexible! Let's try using it in our Bullet app:\n\n{% geshi 'php' %}$app = new Bullet\\App(array(\n    'template.cfg' => array('path' => __DIR__ . '\/templates')\n));\n \n\/\/ 'blog' subdirectory\n$app->path('blog', function($request) use($app) {\n    $blog = somehowGetBlogMapper(\/* where do we get the connection? *\/);\n});{% endgeshi %}\n\nWhoops, we've painted ourselves into a corner. If `somehowGetBlogMapper()`\ndoesn't know how to get the database connection itself, that means the `\/blog`\nroute has to:\n\n{% geshi 'php' %}\/\/ 'blog' subdirectory\n$app->path('blog', function($request) use($app) {\n    $database_connection = somehowGetDatabaseConnection();\n    $blog = somehowGetBlogMapper($database_connection);\n    \n    \/\/ ... more paths and handlers here ...\n});{% endgeshi %}\n\nWait, now the route has to know about the connection **and** the mapper? That\ndoesn't seem more flexible!\n\n## Enter Pimple\n\nLucky for us, our Bullet app doubles as a\n[dependency injection container](http:\/\/www.sitepoint.com\/dependency-injection-with-pimple\/).\nLet's teach Bullet how to create a database connection:\n\n{% geshi 'php' %}$app['database_connection'] = $app->share(function() {\n    return somehowGetDatabaseConnection();\n});{% endgeshi %}\n\nThe `$app->share()` method means that our database connection will be created\nonly once, the first time we request it. Every subsequent request will use the\nsame connection.\n\nNow that Bullet knows how to create our database connection dependency, we can\ninject it into the `\/blog` route:\n\n{% geshi 'php' %}\/\/ 'blog' subdirectory\n$app->path('blog', function($request) use($app) {\n    $blog = somehowGetBlogMapper($app['database_connection']);\n    \n    \/\/ ... more paths and handlers here ...\n});{% endgeshi %}\n\nThat's an improvement; now the route gets the database connection right from\n`$app`. Can we keep going, and teach Bullet to create the blog mapper itself?\n\n{% geshi 'php' %}$app['database_connection'] = $app->share(function() {\n    return somehowGetDatabaseConnection();\n});\n$app['blog_mapper'] = function($app) {\n    return somehowGetBlogMapper($app['database_connection']);\n};\n\n\/\/ 'blog' subdirectory\n$app->path('blog', function($request) use($app) {\n    $blog = $app['blog_mapper'];\n    \n    \/\/ ... more paths and handlers here ...\n});{% endgeshi %}\n\nWhoa, what happened there?\n\n* We taught Bullet to create a database connection.\n* We taught Bullet to create a new blog mapper using that database connection.\n  (Notice how we didn't use `$app->share()` for the mapper? That means Bullet\n  will run `somehowGetBlogMapper()` every time the `blog_mapper` is requested.)\n* In the `\/blog` route, we\n  [asked Bullet directly](https:\/\/www.youtube.com\/watch?v=RlfLCWKxHJ0) for the\n  blog mapper, without worrying about the database connection.\n\nUsing Bullet's built-in dependency injection container, we've managed to not\nonly make our database connection available from our entire app, but also\nremove any blog mapper creation logic from our `\/blog` route. If we need to\nchange that logic later on, we'll only have to modify the injector; not the app\nrouting.\n\n## Further Reading\n\nThis page only brushes the surface of Pimple's (and Bullet's!) dependency\ninjection capabilities. If you want to keep going, read\n[the documentation](https:\/\/github.com\/fabpot\/Pimple\/blob\/1.1\/README.rst)!","format":null}]