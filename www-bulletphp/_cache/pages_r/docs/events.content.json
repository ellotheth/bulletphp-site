[{"content":"## Events\n\nEvents in Bullet allow you to intercept and modify requests before they hit your\napplication, and alter responses after your application sends them, but before\nthey are sent to the browser or user. Events can be used anytime you need to\napply a global behavior to your application when it meets certain conditions.\n\nEvents can be useful for injecting custom responses on specific status codes,\nlike serving a custom \"File Not Found\" page every time a `404` HTTP status is\nsent by your application. They can also be used for things like decoding a\nrequest body a custom way or performing user authentication checks if a cookie\nor HTTP Auth headers are present.\n\n### Named Events\n\nFixed event names that are always fired in a bullet request\/response cycle.\n\n * `before` - Before any route handler is matched or executed\n * `after` - After the last route handler is executed and the response is ready to be sent\n\n### Dynamic Events\n\nDynamic events are dependent upon the response being sent from your\napplication, and are fired just before the `after` event.\n\n * `[http_status_code]` - Like `404`, or `500`, etc.\n * `[response_format]` - Like `html`, `json`, `xml`, etc.\n * `[exception_class]` - Exception class name like `InvalidArgumentException`. Every\nexception also triggers the base `Exception` event that you can use to handle all\nexceptions, and set the HTTP response status to `500` by default.\n\n## Specific Examples\n\nHere are a few examples to get you started with event handling:\n\n### Serving Custom 404 Pages\n\nThis example injects the contents of a custom `errors\/404` template into the response\nevery time the application sends a 404 error.\n\n{% geshi 'php' %}\n$app->on(404, function(\\Bullet\\Request $request, \\Bullet\\Response $response) use($app) {\n    $response->content($app->template('errors\/404')->content());\n});\n{% endgeshi %}\n\nThis example uses [templates](\/docs\/templates) and may require some configuration.\n\n### Capture and log Exceptions\n\nExceptions are unique to other events because instead of only a request and response\nobject getting passed, a third argument is passed - the Exception object. This example\ndisplays Exceptions in a nice format, and logs them to [Sentry](http:\/\/getsentry.com) when in production.\n\n{% geshi 'php' %}\n\/\/ Display exceptions with error and 500 status\n$app->on('Exception', function(\\Bullet\\Request $request, \\Bullet\\Response $response, \\Exception $e) use($app, $raven) {\n    if($request->format() === 'json') {\n        $response->content(array(\n            'exception' => get_class($e),\n            'message' => $e->getMessage()\n        ));\n    } else {\n        $response->content($app->template('errors\/exception', array('e' => $e))->content());\n    }\n\n    if(BULLET_ENV == 'production') {\n        \/\/ Log Exception to Sentry\n        $raven->captureException($e);\n    }\n});\n{% endgeshi %}\n\n","format":null}]