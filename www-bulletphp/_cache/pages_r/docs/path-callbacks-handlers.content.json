[{"content":"## Path Callbacks and Handlers\n\nUnderstanding path callbacks and handlers is key to understanding how Bullet\nparses requests and how it tries to respond to them. Path callbacks are always\nmatched first, and then handlers are executed once the path has been fully\nconsumed and their criteria has been met.\n\n## Path Callbacks\n\nIn your application built with Bullet, a **path callback** is what you will\nuse to structure your URLs and organize your code. Path callbacks are what\nBullet is looking for when trying to respond to a particular request URI.\nIn terms of code, path callbacks will use the `path` and `param` methods on\nthe main Bullet application object.\n\nThe `path` method matches an exact static path name, and the `param` method\nmatches the path based on a registered callback. There are lots of\npre-registered [param callbacks](\/docs\/param-callbacks) and it's easy to add\nyour own custom ones too.\n\nThe following example matches `posts\/235`, but not `posts\/my-post-title`.\n{% geshi 'php' %}\n$app->path('posts', function($request) use($app) {\n    $app->param('int', function($request, $postId) use($app) {\n        return \"Post: \" . $postId;\n    });\n});\n{% endgeshi %}\n\n<div class=\"alert alert-info\">\nPath callbacks are only concerned with\nmatching the URI segment itself, and have no other matching rules or context.\n<\/div>\n\n## Handlers\n\nHandlers are what Bullet uses to send an HTTP response once a path has been\nfully matched. Handler methods are `get`, `post`, `put`, `delete`, `patch`,\n`method`, and `format`. Handler methods are what you should use to contain most\nof your application logic, because handler methods will never be executed unless\nthe full URI has already been matched.\n\nIn this example, a `GET \/posts\/12` will only execute the second `get` handler.\nThe first `get` handler will be ignored because the path was not fully matched\nat that point (only `posts` and not the full `posts\/12`), and the `post` handler\nwill be ignored because the request does not match that handler's criteria (it\nwas a GET request).\n\n{% geshi 'php' %}\n$app->path('posts', function($request) use($app) {\n    \/\/ Get posts collection\n    $app->get(function($request, $postId) use($app) {\n        return \"GET  \/posts\";\n    });\n\n    $app->param('int', function($request, $postId) use($app) {\n        \/\/ Get single post resource\n        $app->get(function($request) use($app, $postId) {\n            return \"GET  \/posts\/\" . $postId;\n        });\n\n        \/\/ Update single post resource\n        $app->post(function($request) use($app, $postId) {\n            return \"POST  \/posts\/\" . $postId;\n        });\n    });\n});\n{% endgeshi %}\n\n<div class=\"alert alert-info\">\n  Handlers are only matched when the entire URI has been fully consumed, and\n  the handler criteria has been matched.\n<\/div>\n\nMultiple hanlders can be nested, and **all** of them will be executed when the\npath has been fully consumed. The most common use for this is combining both an\nHTTP method handler and a format handler. An example `GET \/posts` with an HTTP\nheader `Accept: application\/json` would match the _json_ format handler.\n\n{% geshi 'php' %}\n$app->path('posts', function($request) use($app) {\n    $app->get(function($request, $postId) use($app) {\n        \/\/ Prepare your data ONCE\n        $data = array(\n            array('title' => 'Foo', 'author' => 'Calvin'),\n            array('title' => 'Bar', 'author' => 'Hobbes')\n        );\n\n        \/\/ Respond in multiple formats\n        $app->format('json', function($request) use($app, $data) {\n            return $data;\n        });\n        $app->format('html', function($request) use($app, $data) {\n            return $app->template('posts', $data);\n        });\n    });\n});\n{% endgeshi %}\n\n<div class=\"alert alert-info\">\n  Bullet uses automatic content-negotiation to determine the request format by\n  parsing the `Accept` header in the absense of an explicit file extension.\n<\/div>\n\nReturning the raw array for JSON requests will automatically `json_encode` the\narray and send the appropriate JSON response `Content-Type` header.\n\n\n","format":null}]